{"ast":null,"code":"/** Props that will merge into the modifiers. */\nvar modifierShortcuts = ['selected', 'hidden', 'disabled'];\n/**\n * Parse the modifiers from the props and return them as a map of array of\n * matcher.\n *\n * Internally we want modifiers as an array of matchers – as opposite of the\n * props which can accept also a matcher.\n */\n\nexport function parseModifierProps(initialProps) {\n  var initialModifiers = initialProps.modifiers || {};\n  var modifiers = {\n    selected: [],\n    disabled: [],\n    hidden: [],\n    range_end: [],\n    range_middle: [],\n    range_start: []\n  };\n  Object.entries(initialModifiers).forEach(function (_a) {\n    var modifier = _a[0],\n        matcher = _a[1];\n\n    if (Array.isArray(matcher)) {\n      modifiers[modifier] = matcher;\n    } else if (matcher) {\n      modifiers[modifier] = [matcher];\n    } else {\n      modifiers[modifier] = [];\n    }\n  });\n  modifierShortcuts.forEach(function (modifier) {\n    if (Array.isArray(initialProps[modifier])) {\n      modifiers[modifier] = initialProps[modifier];\n    } else if (initialProps[modifier]) {\n      modifiers[modifier] = [initialProps[modifier]];\n    } else {\n      modifiers[modifier] = [];\n    }\n  });\n  return modifiers;\n}","map":{"version":3,"sources":["../../../../src/contexts/DayPickerContext/utils/parseModifierProps.ts"],"names":[],"mappings":"AAIA;AACA,IAAM,iBAAiB,GAAuB,CAC5C,UAD4C,EAE5C,QAF4C,EAG5C,UAH4C,CAA9C;AAMA;;;;;;AAMG;;AACH,OAAM,SAAU,kBAAV,CAA6B,YAA7B,EAAyD;AAC7D,MAAM,gBAAgB,GAAG,YAAY,CAAC,SAAb,IAA0B,EAAnD;AAEA,MAAM,SAAS,GAAc;AAC3B,IAAA,QAAQ,EAAE,EADiB;AAE3B,IAAA,QAAQ,EAAE,EAFiB;AAG3B,IAAA,MAAM,EAAE,EAHmB;AAI3B,IAAA,SAAS,EAAE,EAJgB;AAK3B,IAAA,YAAY,EAAE,EALa;AAM3B,IAAA,WAAW,EAAE;AANc,GAA7B;AASA,EAAA,MAAM,CAAC,OAAP,CAAe,gBAAf,EAAiC,OAAjC,CAAyC,UAAC,EAAD,EAAoB;QAAlB,QAAQ,GAAA,EAAA,CAAA,CAAA,C;QAAE,OAAO,GAAA,EAAA,CAAA,CAAA,C;;AAC1D,QAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAJ,EAA4B;AAC1B,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,OAAtB;AACD,KAFD,MAEO,IAAI,OAAJ,EAAa;AAClB,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,CAAC,OAAD,CAAtB;AACD,KAFM,MAEA;AACL,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,EAAtB;AACD;AACF,GARD;AAUA,EAAA,iBAAiB,CAAC,OAAlB,CAA0B,UAAC,QAAD,EAAS;AACjC,QAAI,KAAK,CAAC,OAAN,CAAc,YAAY,CAAC,QAAD,CAA1B,CAAJ,EAA2C;AACzC,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,YAAY,CAAC,QAAD,CAAlC;AACD,KAFD,MAEO,IAAI,YAAY,CAAC,QAAD,CAAhB,EAA4B;AACjC,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,CAAC,YAAY,CAAC,QAAD,CAAb,CAAtB;AACD,KAFM,MAEA;AACL,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,EAAtB;AACD;AACF,GARD;AAUA,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["/** Props that will merge into the modifiers. */\nvar modifierShortcuts = [\n    'selected',\n    'hidden',\n    'disabled'\n];\n/**\n * Parse the modifiers from the props and return them as a map of array of\n * matcher.\n *\n * Internally we want modifiers as an array of matchers – as opposite of the\n * props which can accept also a matcher.\n */\nexport function parseModifierProps(initialProps) {\n    var initialModifiers = initialProps.modifiers || {};\n    var modifiers = {\n        selected: [],\n        disabled: [],\n        hidden: [],\n        range_end: [],\n        range_middle: [],\n        range_start: []\n    };\n    Object.entries(initialModifiers).forEach(function (_a) {\n        var modifier = _a[0], matcher = _a[1];\n        if (Array.isArray(matcher)) {\n            modifiers[modifier] = matcher;\n        }\n        else if (matcher) {\n            modifiers[modifier] = [matcher];\n        }\n        else {\n            modifiers[modifier] = [];\n        }\n    });\n    modifierShortcuts.forEach(function (modifier) {\n        if (Array.isArray(initialProps[modifier])) {\n            modifiers[modifier] = initialProps[modifier];\n        }\n        else if (initialProps[modifier]) {\n            modifiers[modifier] = [initialProps[modifier]];\n        }\n        else {\n            modifiers[modifier] = [];\n        }\n    });\n    return modifiers;\n}\n//# sourceMappingURL=parseModifierProps.js.map"]},"metadata":{},"sourceType":"module"}